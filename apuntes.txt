
##Lo que primero que tenemos que hacer:
  Es levantar el servidor y borrar lo que no necesitamos

##Despues creamos una Carpeta public para levantar un servidor estatico. 
  Mirar el HTML y el CSS
  Luego instalamos esta dependencia
  npm i @nestjs/serve-static
  y Luego hacemos la configuracion en el app.module

##Luego crear nuestra RestApi
  nest g res pokemon --no-spec

##Luego hacemos una ruta global en el main.ts

##Despues crear el documento de docker-compose.yaml
  sugerencia seguir a pie de la letra lo que tiene adentro

##Despues instalar esta dependencia
  npm i @nestjs/mongoose mongoose
  Una vez hecho eso, la conexion a la base de datos. en el app.module


##*** Schemas ***##

##Entramos a la Carpeta entities y hacemos lo que esta en el codigo del archivo. 
  Una vez hecho todo eso nos dirigimos al pokemon.module para configurar el schema y sea creada la tabla

##Luego Creamos los datos en el dto
  Primero instalamos estas dependencias npm i class-validator class-transformer
  luego hacemos la configuracion global de las validaciones en el Main
  Depues nos dirigimos al create-pokemon.dto.ts y hacemos lo que esta ahi.

##Guardamos los datos en la Base de datos
  Ahora nos dirigimos al pokemon.service donde haremos estatico
  async create(createPokemonDto: CreatePokemonDto) {
    //Esto para que lo guarde en minuscula
    createPokemonDto.name = createPokemonDto.name.toLocaleLowerCase();
    try {
      const pokemon = await this.pokemonModel.create(createPokemonDto);
      return pokemon;
    } catch (error) {
      if(error.code === 1100){
        //Error de que ya Existe 
        throw new BadRequestException(`Pokemon exists in db ${JSON.stringify(error.keyValue)}`);
      }
      //Error que no sabemos
      console.log(error);
      throw new InternalServerErrorException(`Can't create Pokemon - Check server log`)
    }
  }

  para crear datos y que se conecte con la base de datos

  ##Ahora para verificar o mostrar contenido por id o por algun termino se hace de esta manera
    service y el controller

    //term = termino de busqueda
    async findOne(term: string) {
      let pokemon: Pokemon;
      if(!isNaN(+term)){
        pokemon = await this.pokemonModel.findOne({no: term});
      }
      if(!pokemon && isValidObjectId(term)){
        pokemon = await this.pokemonModel.findById(term);
      }
      if(!pokemon){
        pokemon = await this.pokemonModel.findOne({name: term.toLowerCase().trim() })
      }
      if(!pokemon) throw new NotFoundException(`Pokemon with id, name or no "${term}" not found`);

      return pokemon;
    }

    //term = termino de busqueda
    @Get(':term')
    findOne(@Param('term') term: string) {
      return this.pokemonService.findOne(term);
    }

    ##El Mismon caso para el Actualizar un dato. 
    Pero ahora aumentamos un manejo de errores que lo hacemos de esta manera
      //Manejo de Errores
      private handleExceptions(error: any){
        if(error.code === 1100){
        //Error de que ya Existe algo en la BD 
        throw new BadRequestException(`Pokemon exists in db ${JSON.stringify(error.keyValue)}`);
        }
        console.log(error);
        //Error que no sabemos
        throw new InternalServerErrorException(`Can't create Pokemon - Check server logs`)
      }

    ##Custon Pipes
    Vamos a generar una carpeta common donde manejaremos los custons 
    nest g mo common
    lugo de eso generamos una carpeta pipes
    nest g pi common/pipes/parseMongoId --no-spec

    Y hacemos todo lo que esta en parse-mongo etc 
    y lo mismo en remove service etc etc

    ##